Microsoft Windows [Version 10.0.19044.1826]
(c) Microsoft Corporation. All rights reserved.

C:\Users\mikmoran>ssh root@139.178.84.27
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.13.0-44-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Aug 10 15:07:26 UTC 2022

  System load:            0.0
  Usage of /:             1.5% of 218.06GB
  Memory usage:           1%
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.13.0-44-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Aug 10 15:07:26 UTC 2022

  System load:            0.0
  Usage of /:             1.5% of 218.06GB
  Memory usage:           1%
  Swap usage:             0%
  Processes:              497
  Users logged in:        1
  IPv4 address for bond0: 139.178.84.27
  IPv6 address for bond0: 2604:1380:4641:3b00::13


8 updates can be applied immediately.
8 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable


The list of available updates is more than a week old.
To check for new updates run: sudo apt update
Your Hardware Enablement Stack (HWE) is supported until April 2025.

Last login: Wed Aug 10 15:07:07 2022 from 165.204.78.25
root@mm60:~# uname -a
Linux mm60 5.13.0-44-generic #49~20.04.1-Ubuntu SMP Wed May 18 18:44:28 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
root@mm60:~# export KUBECONFIG=/var/run/kubernetes/admin.kubeconfig
root@mm60:~# cd /usr/local/bin/
root@mm60:/usr/local/bin# curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   154  100   154    0     0   4162      0 --:--:-- --:--:-- --:--:--  4162
100 43.5M  100 43.5M    0     0   189M      0 --:--:-- --:--:-- --:--:--  189M
root@mm60:/usr/local/bin# chmod +x kubectl
root@mm60:/usr/local/bin# cd
root@mm60:~# kubectl get nodes
NAME        STATUS   ROLES    AGE     VERSION
127.0.0.1   Ready    <none>   8m38s   v1.24.0-beta.0.2166+2bea4b24e24bf2
root@mm60:~# git clone http://github.com/vmware/weathervane
Cloning into 'weathervane'...
warning: redirecting to https://github.com/vmware/weathervane/
remote: Enumerating objects: 19144, done.
remote: Counting objects: 100% (1935/1935), done.
remote: Compressing objects: 100% (629/629), done.
remote: Total 19144 (delta 1003), reused 1876 (delta 960), pack-reused 17209
Receiving objects: 100% (19144/19144), 64.62 MiB | 24.32 MiB/s, done.
Resolving deltas: 100% (11699/11699), done.
root@mm60:~# cd weathervane/
root@mm60:~/weathervane# mkdir -p /k8s/weathervane/vol
root@mm60:~/weathervane# cat > create-persistent-vol.yaml << EOF
> apiVersion: v1
> kind: PersistentVolume
> metadata:
>   name: weathervane-pv
> spec:
>   capacity:
    storage: 50Gi
  accessModes:
  ->     storage: 50Gi
>   accessModes:
>   - ReadWriteOnce
olumeReclaimPolicy: Retain
 >   persistentVolumeReclaimPolicy: Retain
>   storageClassName: local-storage
  path: /k8s/we>   local:
>     path: /k8s/weathervane/vol
>   nodeAffinity:
>     required:
>       nodeSelectorTerms:
>       - matchExpressions:
>         - key: kubernetes.io/hostname
>           operator: In
>           values:
>           - 127.0.0.1
> EOF
root@mm60:~/weathervane# kubectl apply -f create-persistent-vol.yaml
persistentvolume/weathervane-pv created
root@mm60:~/weathervane# cat > create-storage-class.yaml << EOF
d: Sto> kind: StorageClass
> apiVersion: storage.k8s.io/v1
> metadata:
>   name: local-storage
> provisioner: kubernetes.io/no-provisioner
> volumeBindingMode: WaitForFirstConsumer
> EOF
root@mm60:~/weathervane# kubectl apply -f create-storage-class.yaml
storageclass.storage.k8s.io/local-storage created
root@mm60:~/weathervane# kubectl get persistentvolume
NAME             CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS    REASON   AGE
weathervane-pv   50Gi       RWO            Retain           Available           local-storage            6m19s
root@mm60:~/weathervane# kubectl get storageclass
NAME                 PROVISIONER                    RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
local-storage        kubernetes.io/no-provisioner   Delete          WaitForFirstConsumer   false                  6m
standard (default)   kubernetes.io/host-path        Delete          Immediate              false                  84m
root@mm60:~/weathervane# kubectl get storageclass
NAME                 PROVISIONER                    RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
local-storage        kubernetes.io/no-provisioner   Delete          WaitForFirstConsumer   false                  10m
standard (default)   kubernetes.io/host-path        Delete          Immediate              false                  89m
root@mm60:~/weathervane# uptime
 17:30:40 up  2:33,  2 users,  load average: 0.08, 0.03, 0.00
root@mm60:~/weathervane# history
    1  uname -a
    2  export KUBECONFIG=/var/run/kubernetes/admin.kubeconfig
    3  cd /usr/local/bin/
    4  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    5  chmod +x kubectl
    6  cd
    7  kubectl get nodes
    8  git clone http://github.com/vmware/weathervane
    9  cd weathervane/
   10  mkdir -p /k8s/weathervane/vol
   11  cat > create-persistent-vol.yaml << EOF
apiVersion: v1
kind: PersistentVolume
metadata:
  name: weathervane-pv
spec:
  capacity:
    storage: 50Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /k8s/weathervane/vol
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 127.0.0.1
EOF

   12  kubectl apply -f create-persistent-vol.yaml
   13  cat > create-storage-class.yaml << EOF
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
EOF

   14  kubectl apply -f create-storage-class.yaml
   15  kubectl get persistentvolume
   16  kubectl get storageclass
   17  uptime
   18  history
root@mm60:~/weathervane#
root@mm60:~/weathervane# ll
total 260
drwxr-xr-x 16 root root  4096 Aug 10 16:39 ./
drwx------  8 root root  4096 Aug 10 15:35 ../
drwxr-xr-x  8 root root  4096 Aug 10 15:35 .git/
-rw-r--r--  1 root root  2411 Aug 10 15:35 .gitignore
-rw-r--r--  1 root root  2959 Aug 10 15:35 BRANCHING.md
-rw-r--r--  1 root root   200 Aug 10 15:35 Branches.md
-rw-r--r--  1 root root  5247 Aug 10 15:35 CODE-OF-CONDUCT.md
-rw-r--r--  1 root root  9540 Aug 10 15:35 CONTRIBUTING.md
-rw-r--r--  1 root root  4952 Aug 10 15:35 ISSUES.md
-rw-r--r--  1 root root  1485 Aug 10 15:35 LICENSE.txt
-rw-r--r--  1 root root   454 Aug 10 15:35 Notice.txt
-rw-r--r--  1 root root  4585 Aug 10 15:35 README.md
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionApp/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionAppServerWarmer/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionBidService/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionWeb/
-rw-r--r--  1 root root 10152 Aug 10 15:35 build.gradle
-rwxr-xr-x  1 root root 13779 Aug 10 15:35 buildDockerImages.pl*
drwxr-xr-x  4 root root  4096 Aug 10 15:35 configFiles/
-rw-r--r--  1 root root   436 Aug 10 16:38 create-persistent-vol.yaml
-rw-r--r--  1 root root   163 Aug 10 16:39 create-storage-class.yaml
drwxr-xr-x  3 root root  4096 Aug 10 15:35 dbLoader/
drwxr-xr-x  8 root root  4096 Aug 10 15:35 doc/
drwxr-xr-x 14 root root  4096 Aug 10 15:35 dockerImages/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 gradle/
-rw-r--r--  1 root root    20 Aug 10 15:35 gradle.properties
-rwxr-xr-x  1 root root  5305 Aug 10 15:35 gradlew*
-rwxr-xr-x  1 root root  2185 Aug 10 15:35 gradlew.bat*
drwxr-xr-x 14 root root  4096 Aug 10 15:35 runHarness/
-rwxr-xr-x  1 root root 20497 Aug 10 15:35 runWeathervane.pl*
-rwxr-xr-x  1 root root  2527 Aug 10 15:35 runmany.sh*
-rw-r--r--  1 root root   145 Aug 10 15:35 settings.gradle
drwxr-xr-x  3 root root  4096 Aug 10 15:35 testing/
-rw-r--r--  1 root root     6 Aug 10 15:35 version.txt
-rw-r--r--  1 root root   708 Aug 10 15:35 weathervane.config.k8s.micro
-rw-r--r--  1 root root   721 Aug 10 15:35 weathervane.config.k8s.small2
-rwxr-xr-x  1 root root 42556 Aug 10 15:35 weathervane.pl*
drwxr-xr-x  3 root root  4096 Aug 10 15:35 workloadConfiguration/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 workloadDriver/
root@mm60:~/weathervane# cat runWeathervane.pl
#!/usr/bin/perl
# Copyright 2017-2019 VMware, Inc.
# SPDX-License-Identifier: BSD-2-Clause
#
# Created by: Hal Rosenberg
#
# This is the entrypoint to Weathervane
#
package Weathervane;
use strict;
use Getopt::Long;
no if $] >= 5.017011, warnings => 'experimental::smartmatch';

my $accept = '';
my $configFile = 'weathervane.config';
my $version = '2.0.0';
my $outputDir = 'output';
my $tmpDir = '';
my $backgroundScript = '';
my $mapSsh = '';
my $skipPvTest = '';
my $fixedConfigsFile = "";
my $scriptPeriodSec = 60;
my $help = '';
my $startStatsScript = '';
my $stopStatsScript = '';

# Turn on auto flushing of output
BEGIN { $| = 1 }

if ((-e "./version.txt") && (-f "./version.txt")) {
  $version = `cat ./version.txt`;
  chomp($version);
}
my $defaultVersion = $version;

GetOptions(     'accept!' => \$accept,
                        'configFile=s' => \$configFile,
                        'outputDir=s' => \$outputDir,
                        'version=s' => \$version,
                        'tmpDir=s' => \$tmpDir,
                        'script=s' => \$backgroundScript,
                        'fixedConfigsFile=s' => \$fixedConfigsFile,
                        'startStatsScript=s' => \$startStatsScript,
                        'stopStatsScript=s' => \$stopStatsScript,
                        'scriptPeriod=i' => \$scriptPeriodSec,
                        'mapSsh!' => \$mapSsh,
                        'skipPvTest!' => \$skipPvTest,
                        'help!' => \$help,
                );

my $wvCommandLineArgs = join(" ", @ARGV);

sub usage {
    print "Usage: ./runWeathervane.pl [options] [-- parameters]\n";
        print "\nThis script is used to run the Weathervane benchmark using the configuration specified in a configuration file.\n";
        print "It takes the following options:\n";
        print "--configFile: This specifies the configuration file used to control the Weathervane run.\n";
        print "              If this parameter is not a fully-qualified file name starting with a \/ then\n";
        print "              the location of the file is assumed to be relative to the directory in which\n";
        print "              this script was invoked.\n";
        print "              For a description of the Weathervane configuration file, please see the \n";
        print "              Weathervane User's Guide\n";
        print "              default value: weathervane.config\n";
        print "--version:    The version of Weathervane to use.  This will override the default version\n";
        print "              number to use for the Weathervane container images.\n";
        print "              default value: $defaultVersion\n";
        print "--outputDir:  The directory in which to store the output from the Weathervane run.  You should\n";
        print "              use the same directory for all runs. Output is only placed in this directory\n";
        print "              at the end of a run.  The directory is created if it does not exist.\n";
        print "              If this parameter is not a fully-qualified file name starting with a \/ then\n";
        print "              the location of the file is assumed to be relative to the directory in which\n";
        print "              this script was invoked.\n";
        print "              default value: output\n";
        print "--tmpDir:     The directory in which to store temporary output created during the run.\n";
        print "              This information can be helpful when troubleshooting runs which do not complete\n";
        print "              properly.  The directory is created if it does not exist.\n";
        print "              If this parameter is not a fully-qualified file name starting with a \/ then\n";
        print "              the location of the file is assumed to be relative to the directory in which\n";
        print "              this script was invoked.\n";
        print "              default value: None.  If no value is specified the temporary files are stored\n";
        print "                             inside the Weathervane container.\n";
        print "--script:     The path to a script that should be run every scriptPeriod seconds.\n";
        print "              The script may be used to refresh the credentials in the kubeconfig file\n";
        print "              or to trigger external stats collection.\n";
        print "              If this parameter is not a fully-qualified file name starting with a \/ then\n";
        print "              the location of the file is assumed to be relative to the directory in which\n";
        print "              this script was invoked.\n";
        print "              default value: None.\n";
        print "--scriptPeriod: The frequency at which the script should be run in seconds.\n";
        print "              default value: 60\n";
        print "--mapSsh:     Causes the user's \$HOME/.ssh directory to be mapped into the run harness container.\n";
        print "              This is only needed when collecting esxtop data, which requires passwordless ssh.\n";
        print "              default value: False\n";
        print "--accept:     Accepts the terms of the Weathervane license.  Useful when running this script\n";
        print "              from another script.  Only needs to be specified on the first run in a given directory.\n";
        print "              default value: None.  If no value is specified the user is prompted to accept the\n";
        print "                             license terms.\n";
        print "--skipPvTest: Causes the scipt to skip testing whether Weathervane can dynamically allocate \n";
        print "              persistant volumes in the storage classes defined in the configuration file.\n";
        print "              default value: False";
        print "--help:       Displays this text.\n";
        print "\n";
        print "To pass command-line parameters to the Weathervane run harness, enter them following two dashes\n";
        print "after the options.  For example, to stop the services from a previous run you would use:\n";
        print "./runWeathervane.pl --configFile=weathervane.config -- --stop\n";
}

sub parseConfigFile {
        my ($configFileName, $dockerNamespace) = @_;

        # Read in the config file
        open( my $configFile, "<$configFileName" ) or die "Couldn't open configuration file $configFileName: $!\n";

        my @k8sConfigFiles;
        my %clusterNameToKubeconfig;
        my $topLevelAppInstanceCluster = "";
        my %topLevelStorageClassNames;
        # Parsing the config file manually to avoid requiring the JSON package
        while (<$configFile>) {
                if ($_ =~ /^\s*#/) {
                                next;
                } elsif ($_ =~ /^\s*"kubernetesClusters"\s*\:\s*\[/) {
                        # Fill out a hash with clustername -> [kubeconfig, context])
                        while (<$configFile>) {
                                if ($_ =~ /^\s*#/) {
                                        next;
                                } elsif ($_ =~ /^\s*{/) {
                                        my $name = "";
                                        my $kubeconfigFileName = "~/.kube/config";
                                        my $kubeconfigContext = "";
                                        while (<$configFile>) {
                                                if ($_ =~ /^\s*#/) {
                                                        next;
                                                } elsif ($_ =~ /^\s*"kubeconfigFile"\s*\:\s*"(.*)"\s*,/) {
                                                        $kubeconfigFileName = $1;
                                                        if ((! -e $kubeconfigFileName) || (! -f $kubeconfigFileName)) {
                                                                print "The kubeconfigFile $kubeconfigFileName must exist and be a regular file.\n";
                                                                usage();
                                                                exit 1;

                                                        }
                                                        if (!($kubeconfigFileName ~~ @k8sConfigFiles)) {
                                                                push(@k8sConfigFiles, $kubeconfigFileName);
                                                        }
                                                } elsif ($_ =~ /^\s*"kubeconfigContext"\s*\:\s*"(.*)"\s*,/) {
                                                        $kubeconfigContext = $1;
                                                } elsif ($_ =~ /^\s*"name"\s*\:\s*"(.*)"\s*,/) {
                                                        $name = $1;
                                                } elsif ($_ =~ /^\s*\}/) {
                                                        last;
                                                }
                                        }
                                        $clusterNameToKubeconfig{$name} = [$kubeconfigFileName, $kubeconfigContext];

                                } elsif ($_ =~ /^\s*\]/) {
                                        last;
                                }
                        }
                } elsif ($_ =~ /^\s*"workloads"\s*\:\s*\[/) {
                        # Don't parse inside workloads
                        my $numOpenBrackets = 1;
                        while (<$configFile>) {
                                if ($_ =~ /^\s*#/) {
                                        next;
                                } elsif ($_ =~ /\[/) {
                                        $numOpenBrackets++;
                                } elsif ($_ =~ /\]/) {
                                        $numOpenBrackets--;
                                        if ($numOpenBrackets == 0) {
                                                last;
                                        }
                                }
                        }
                } elsif ($_ =~ /^\s*"appInstances"\s*\:\s*\[/) {
                        # Don't parse inside appInstances
                        my $numOpenBrackets = 1;
                        while (<$configFile>) {
                                if ($_ =~ /^\s*#/) {
                                        next;
                                } elsif ($_ =~ /\[/) {
                                        $numOpenBrackets++;
                                } elsif ($_ =~ /\]/) {
                                        $numOpenBrackets--;
                                        if ($numOpenBrackets == 0) {
                                                last;
                                        }
                                }
                        }
                } elsif ($_ =~ /StorageClass"\s*\:\s*"(.*)"\s*,/) {
                        $topLevelStorageClassNames{$1} = 1;
                } elsif ($_ =~ /appInstanceCluster"\s*\:\s*"(.*)"\s*,/) {
                        $topLevelAppInstanceCluster = $1;
                } elsif (!$dockerNamespace && ($_ =~ /^\s*"dockerNamespace"\s*\:\s*"(.*)"\s*,/)) {
                        $dockerNamespace = $1;
                } elsif ($_ =~ /useLoadBalancer/) {
                        print "The useLoadBalancer parameter has been replaced with the appIngressMethod parameter. " .
                                "You must update your configuration file.\n" .
                                "Please refer to the Weathervane User's Guide for information on setting the appIngressMethod parameter.\n";
                        exit(1);
                }
        }
        close $configFile;

        if (!$dockerNamespace) {
                print "You must specify the dockerNamespace parameter either in configuration file $configFileName or on the command-line.\n";
                usage();
                exit 1;
        }

        my %clusterToStorageClassNames;
        if ($topLevelAppInstanceCluster) {
                $clusterToStorageClassNames{$topLevelAppInstanceCluster} = \%topLevelStorageClassNames;
        }

        my @return = (\@k8sConfigFiles, $dockerNamespace, \%clusterNameToKubeconfig, \%clusterToStorageClassNames);

        return \@return;
}

sub checkStorageClasses {
        my ($clusterNameToKubeconfigRef, $clusterToStorageClassNamesRef) = @_;

        my $pvcYamlString = <<"END";
{
  \\\"kind\\\": \\\"PersistentVolumeClaim\\\",
  \\\"apiVersion\\\": \\\"v1\\\",
  \\\"metadata\\\": {
    \\\"name\\\": \\\"weathervane-test-claim\\\",
    \\\"annotations\\\": {
        \\\"volume.beta.kubernetes.io/storage-class\\\": \\\"storageClassNameHere\\\"
    }
  },
  \\\"spec\\\": {
    \\\"accessModes\\\": [
      \\\"ReadWriteOnce\\\"
    ],
    \\\"resources\\\": {
      \\\"requests\\\": {
        \\\"storage\\\": \\\"1Mi\\\"
      }
    }
  }
}
END

        foreach my $clusterName (keys %$clusterToStorageClassNamesRef) {
                my $kubeconfigFileName = $clusterNameToKubeconfigRef->{$clusterName}->[0];
                my $kubeconfigContext = $clusterNameToKubeconfigRef->{$clusterName}->[1];
                foreach my $storageClassName (keys %{$clusterToStorageClassNamesRef->{$clusterName}}) {
                        # Delete any old PVC with name weathervane-test-claim
                        my $out = `kubectl --kubeconfig=$kubeconfigFileName --context=$kubeconfigContext delete pvc weathervane-test-claim 2>&1`;

                        # Create a PVC
                        my $pvcYamlStringCopy = $pvcYamlString;
                        $pvcYamlStringCopy =~ s/storageClassNameHere/$storageClassName/;
                        $out = `echo "$pvcYamlStringCopy" | kubectl --kubeconfig=$kubeconfigFileName --context=$kubeconfigContext apply -f -`;

                        # Check 5 times for the status to equal Bound and exit if not sucessful
                        my $retries = 5;
                        my $status;
                        do {
                                $status = `kubectl --kubeconfig=$kubeconfigFileName --context=$kubeconfigContext get pvc weathervane-test-claim -o=jsonpath='{.status.phase}'`;
                                chomp($status);
                                $retries--;
                                if ($status ne "Bound") {
                                        if ($retries == 0) {
                                                $out = `kubectl --kubeconfig=$kubeconfigFileName --context=$kubeconfigContext delete pvc weathervane-test-claim 2>&1`;
                                                die "Weathervane is unable to create a persistant volume using storage class $storageClassName in kubernetesCluster $clusterName.\n" .
                                            "Check the configuration of your cluster to ensure that the storage class exists and can provision persistent volumes.\n";
                                        }
                                        sleep 5;
                                }
                        } while (($status ne "Bound") && ($retries > 0));

                        # Delete the PVC
                        $out = `kubectl --kubeconfig=$kubeconfigFileName --context=$kubeconfigContext delete pvc weathervane-test-claim 2>&1`;
                }
        }
}
sub parseKubeconfigFile {
        my ($configFileName) = @_;

        # Read in the config file
        open( CONFIGFILE, "<$configFileName" ) or die "Couldn't open configuration file $configFileName: $!\n";
        my @files;
        while (<CONFIGFILE>) {
                if ($_ =~ /^\s*[a-zA-Z0-9\-_]+:\s*(\/.*)$/) {
                        push @files, $1;
                }
        }
        close CONFIGFILE;

        return \@files;
}

sub dockerExists {
        my ( $name ) = @_;
        my $out = `docker ps -a`;
        my @lines = split /\n/, $out;
        my $found = 0;
        foreach my $line (@lines) {
                if ($line =~ /\s+$name\s*$/) {
                        $found = 1;
                        last;
                }
        }
        return $found;
}

sub runPeriodicScript {
        `$backgroundScript`;
        my $pid = fork();
        if (!defined $pid ) {
                die("Couldn't fork a process to run background script: $!\n");
        } elsif ( $pid == 0 ) {
                while (1) {
                        `$backgroundScript`;
                        sleep($scriptPeriodSec);
                }
                exit;
        }
        return $pid;
}

# Force acceptance of the license if not using the accept parameter
sub forceLicenseAccept {
        open( my $fileout, "./Notice.txt" ) or die "Can't open file ./Notice.txt: $!\n";
        while ( my $inline = <$fileout> ) {
                print $inline;
        }

        print "Do you accept these terms and conditions (yes/no)? ";
        my $answer = <STDIN>;
        chomp($answer);
        $answer = lc($answer);
        while ( ( $answer ne "yes" ) && ( $answer ne "no" ) ) {
                print "Please answer yes or no: ";
                $answer = <STDIN>;
                chomp($answer);
                $answer = lc($answer);
        }
        if ( $answer eq "yes" ) {
                open( my $file, ">./.accept-weathervane" ) or die "Can't create file ./.accept-weathervane: $!\n";
                close $file;
        }
        else {
                exit -1;
        }

}

if ($help) {
        usage();
        exit 0;
}

unless ( -e "./.accept-weathervane" ) {
        if ($accept) {
                open( my $file, ">./.accept-weathervane" ) or die "Can't create file ./.accept-weathervane: $!\n";
                close $file;
        }
        else {
                forceLicenseAccept();
        }
}

if (!(-e $configFile)) {
        print "You must specify a valid configuration file using the configFile parameter.  The file $configFile does not exist.\n";
        usage();
        exit 1;
}
if (!(-f $configFile)) {
        print "The Weathervane configuration file $configFile must not be a directory.\n";
        usage();
        exit 1;
}
# If the configFile does not reference a file with an absolute path,
# then make it an absolute path relative to the local dir
my $pwd = `pwd`;
chomp($pwd);
if (!($configFile =~ /\//)) {
        $configFile = "$pwd/$configFile";
}

# If the outputDir does not reference a directory with an absolute path,
# then make it an absolute path relative to the local dir
if (!($outputDir =~ /\//)) {
        $outputDir = "$pwd/$outputDir";
}
if (!(-e $outputDir)) {
        `mkdir -p $outputDir`;
}
if (!(-d $outputDir)) {
        print "The Weathervane output directory $outputDir must be a directory.\n";
        usage();
        exit 1;
}
my $outputMountString = "-v $outputDir:/root/weathervane/output";

# Mounting the tmpDir is optional.
my $tmpMountString = "";
if ($tmpDir) {
        # If the tmpDir does not reference a directory with an absolute path,
        # then make it an absolute path relative to the local dir
        if (!($tmpDir =~ /\//)) {
                $tmpDir = "$pwd/$tmpDir";
        }
        if (!(-e $tmpDir)) {
                `mkdir -p $tmpDir`;
        }
        if (!(-d $tmpDir)) {
                print "The Weathervane tmp directory $tmpDir must be a directory.\n";
                usage();
                exit 1;
        }
        $tmpMountString = "-v $tmpDir:/root/weathervane/tmpLog";
}

if ($backgroundScript) {
        # If the $backgroundScript does not reference a file with an absolute path,
        # then make it an absolute path relative to the local dir
        if (!($backgroundScript =~ /\//)) {
                $backgroundScript = "$pwd/$backgroundScript";
        }
        if (!(-e $backgroundScript)) {
                die "The script $backgroundScript does not exist.\n";
        }
        if (!(-f $backgroundScript)) {
                print "The script $backgroundScript must be a file.\n";
                exit 1;
        }
        if (!(-x $backgroundScript)) {
                print "The script $backgroundScript must be a executable.\n";
                exit 1;
        }
}

if (dockerExists("weathervane")) {
    `docker rm -vf weathervane`;
}

my $resultsFile = "$pwd/weathervaneResults.csv";
if (!(-e $resultsFile)) {
        `touch $resultsFile`;
} elsif (-d $resultsFile) {
        die "The file $resultsFile must be an ordinary file";
}

my $homeDir = $ENV{'HOME'};
my $sshMountString = "";
if ($mapSsh && (-e "$homeDir/.ssh") && (-d "$homeDir/.ssh")) {
    $sshMountString = "-v $homeDir/.ssh:/root/.ssh";
}

my $dockerNamespace;
# Determine whether the dockerNamespace is set in the command-line
# options that are getting passed to the runHarness
if ($wvCommandLineArgs =~ /\-\-dockerNamespace(\=|\s)([^\s]*)(\s|$)/) {
        $dockerNamespace = $2;
}

my $retRef = parseConfigFile($configFile, $dockerNamespace);
my $k8sConfigFilesRef = $retRef->[0];
$dockerNamespace = $retRef->[1];
my $clusterNameToKubeconfigRef = $retRef->[2];
my $clusterToStorageClassNamesRef = $retRef->[3];

if (!$skipPvTest) {
        checkStorageClasses($clusterNameToKubeconfigRef, $clusterToStorageClassNamesRef);
}

my $k8sConfigMountString = "";
foreach my $k8sConfig (@$k8sConfigFilesRef) {
        # If the config file doesn't have an absolute path,
        # then mount it in /root/weathervane
        if ($k8sConfig =~ /^\//) {
                $k8sConfigMountString .= "-v $k8sConfig:$k8sConfig ";
        } else {
                $k8sConfigMountString .= "-v $k8sConfig:/root/weathervane/$k8sConfig ";
        }

        # Also mount any files that are referenced in the kubeconfig file
        my $kubeconfigFilesRef = parseKubeconfigFile($k8sConfig);
        foreach my $file (@$kubeconfigFilesRef) {
                $k8sConfigMountString .= "-v $file:$file ";
        }
}



my $configMountString = "-v $configFile:/root/weathervane/weathervane.config";
my $resultsMountString = "-v $resultsFile:/root/weathervane/weathervaneResults.csv";

my $fixedConfigsMountString = "";
if ($fixedConfigsFile) {
        # If the fixedConfigsFile does not reference a file with an absolute path,
        # then make it an absolute path relative to the local dir
        if (!($fixedConfigsFile =~ /\//)) {
                $fixedConfigsFile = "$pwd/$fixedConfigsFile";
        }
        if (!(-e "$fixedConfigsFile") || !(-f "$fixedConfigsFile")) {
                die "fixedConfigsFile $fixedConfigsFile must exist\n";
        } else {
                $fixedConfigsMountString = "-v $fixedConfigsFile:/root/weathervane/runHarness/fixedConfigs.json";
        }
}

my $startStatsScriptMountString = "";
if ($startStatsScript) {
        # If the $startStatsScript does not reference a file with an absolute path,
        # then make it an absolute path relative to the local dir
        if (!($startStatsScript =~ /\//)) {
                $startStatsScript = "$pwd/$startStatsScript";
        }
        if (!(-e $startStatsScript)) {
                die "The script $startStatsScript does not exist.\n";
        }
        if (!(-f $startStatsScript)) {
                print "The script $startStatsScript must be a file.\n";
                exit 1;
        }
        if (!(-x $startStatsScript)) {
                print "The script $startStatsScript must be a executable.\n";
                exit 1;
        }
        $startStatsScriptMountString = "-v $startStatsScript:$startStatsScript";
        $wvCommandLineArgs .= " --startStatsScript $startStatsScript"
}

my $stopStatsScriptMountString = "";
if ($stopStatsScript) {
        # If the $stopStatsScript does not reference a file with an absolute path,
        # then make it an absolute path relative to the local dir
        if (!($stopStatsScript =~ /\//)) {
                $stopStatsScript = "$pwd/$stopStatsScript";
        }
        if (!(-e $stopStatsScript)) {
                die "The script $stopStatsScript does not exist.\n";
        }
        if (!(-f $stopStatsScript)) {
                print "The script $stopStatsScript must be a file.\n";
                exit 1;
        }
        if (!(-x $stopStatsScript)) {
                print "The script $stopStatsScript must be a executable.\n";
                exit 1;
        }
        $stopStatsScriptMountString = "-v $stopStatsScript:$stopStatsScript";
        $wvCommandLineArgs .= " --stopStatsScript $stopStatsScript"
}

my $tz = `date +%Z`;
chomp($tz);
my $tzEnvString = "-e TZ=$tz";

# Stop an existing run harness container
if (dockerExists("weathervane")) {
    `docker rm -vf weathervane`;
}

my $pid = '';
if ($backgroundScript) {
        print "Running script $backgroundScript every $scriptPeriodSec seconds.\n";
        $pid = runPeriodicScript();
}

# make sure the docker image is up-to-date
print "Starting Weathervane Run-Harness.  Pulling container image may take a few minutes.\n";
`docker pull $dockerNamespace/weathervane-runharness:$version`;

my $cmdString = "docker run --name weathervane --net host $tzEnvString -d -w /root/weathervane "
                . "$configMountString $resultsMountString $k8sConfigMountString $fixedConfigsMountString "
                . "$outputMountString $tmpMountString $sshMountString "
                . "$startStatsScriptMountString $stopStatsScriptMountString "
                . "$dockerNamespace/weathervane-runharness:$version $wvCommandLineArgs";
my $dockerId = `$cmdString`;

my $pipeString = "docker logs --follow weathervane |";
my $pipePid = open my $driverPipe, "$pipeString"
          or die "Can't open docker logs pipe ($pipeString) : $!\n";

my $inline;
while ( $driverPipe->opened() &&  ($inline = <$driverPipe>) ) {
    print $inline;
}

if ($pid) {
        kill 9, $pid;
}

my $exitCode = `docker inspect weathervane --format='{{.State.ExitCode}}'`;
`docker rm weathervane`;
chomp($exitCode);
if ($exitCode != 0) {
        print "Exit code for Run-Harness container is $exitCode.\n";
        exit $exitCode;
}
root@mm60:~/weathervane# vi runWeathervane.pl
root@mm60:~/weathervane# cat > weathervane.config.k8s.quickstart << EOF
> {
>   "description" : "micro",
>
>   "configurationSize": "micro",
egy" :>
>   "runStrategy" : "fixed",
>
>   "dockerNamespace" : "mikemoranamd",
lusters" : [
    {
 >   "kubernetesClusters" : [
>     {
>       "name" : "appCluster",
>       "kubeconfigFile" : "/var/run/kubernetes/admin.kubeconfig",
 "",
 >       "kubeconfigContext" : "",
>     },
>     {
>       "name" : "driverCluster",
configF>       "kubeconfigFile" : "/var/run/kubernetes/admin.kubeconfig",
>       "kubeconfigContext" : "",
>     },
>   ],
>
>   "driverCluster" : "driverCluster",
>
>   "appInstanceCluster" : "appCluster",
>   "appIngressMethod" : "clusterip",
>
>   "cassandraDataStorageClass" : "weathervane-pv",
>   "postgresqlStorageClass" : "weathervane-pv",
>   "nginxCacheStorageClass" : "weathervane-pv",
>
> }
> EOF
root@mm60:~/weathervane# vi *.q*
root@mm60:~/weathervane# root@mm60:~/weathervane# ll
total 264
drwxr-xr-x 16 root root  4096 Aug 10 17:50 ./
drwx------  8 root root  4096 Aug 10 17:50 ../
drwxr-xr-x  8 root root  4096 Aug 10 15:35 .git/
-rw-r--r--  1 root root  2411 Aug 10 15:35 .gitignore
-rw-r--r--  1 root root  2959 Aug 10 15:35 BRANCHING.md
-rw-r--r--  1 root root   200 Aug 10 15:35 Branches.md
-rw-r--r--  1 root root  5247 Aug 10 15:35 CODE-OF-CONDUCT.md
-rw-r--r--  1 root root  9540 Aug 10 15:35 CONTRIBUTING.md
-rw-r--r--  1 root root  4952 Aug 10 15:35 ISSUES.md
-rw-r--r--  1 root root  1485 Aug 10 15:35 LICENSE.txt
-rw-r--r--  1 root root   454 Aug 10 15:35 Notice.txt
-rw-r--r--  1 root root  4585 Aug 10 15:35 README.md
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionApp/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionAppServerWarmer/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionBidService/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 auctionWeb/
-rw-r--r--  1 root root 10152 Aug 10 15:35 build.gradle
-rwxr-xr-x  1 root root 13779 Aug 10 15:35 buildDockerImages.pl*
drwxr-xr-x  4 root root  4096 Aug 10 15:35 configFiles/
-rw-r--r--  1 root root   436 Aug 10 16:38 create-persistent-vol.yaml
-rw-r--r--  1 root root   163 Aug 10 16:39 create-storage-class.yaml
drwxr-xr-x  3 root root  4096 Aug 10 15:35 dbLoader/
drwxr-xr-x  8 root root  4096 Aug 10 15:35 doc/
drwxr-xr-x 14 root root  4096 Aug 10 15:35 dockerImages/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 gradle/
-rw-r--r--  1 root root    20 Aug 10 15:35 gradle.properties
-rwxr-xr-x  1 root root  5305 Aug 10 15:35 gradlew*
-rwxr-xr-x  1 root root  2185 Aug 10 15:35 gradlew.bat*
drwxr-xr-x 14 root root  4096 Aug 10 15:35 runHarness/
-rwxr-xr-x  1 root root 20497 Aug 10 15:35 runWeathervane.pl*
-rwxr-xr-x  1 root root  2527 Aug 10 15:35 runmany.sh*
-rw-r--r--  1 root root   145 Aug 10 15:35 settings.gradle
drwxr-xr-x  3 root root  4096 Aug 10 15:35 testing/
-rw-r--r--  1 root root     6 Aug 10 15:35 version.txt
-rw-r--r--  1 root root   708 Aug 10 15:35 weathervane.config.k8s.micro
-rw-r--r--  1 root root   701 Aug 10 17:50 weathervane.config.k8s.quickstart
-rw-r--r--  1 root root   721 Aug 10 15:35 weathervane.config.k8s.small2
-rwxr-xr-x  1 root root 42556 Aug 10 15:35 weathervane.pl*
drwxr-xr-x  3 root root  4096 Aug 10 15:35 workloadConfiguration/
drwxr-xr-x  3 root root  4096 Aug 10 15:35 workloadDriver/
root@mm60:~/weathervane# history
    1  uname -a
    2  export KUBECONFIG=/var/run/kubernetes/admin.kubeconfig
    3  cd /usr/local/bin/
    4  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    5  chmod +x kubectl
    6  cd
    7  kubectl get nodes
    8  git clone http://github.com/vmware/weathervane
    9  cd weathervane/
   10  mkdir -p /k8s/weathervane/vol
   11  cat > create-persistent-vol.yaml << EOF
apiVersion: v1
kind: PersistentVolume
metadata:
  name: weathervane-pv
spec:
  capacity:
    storage: 50Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /k8s/weathervane/vol
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 127.0.0.1
EOF

   12  kubectl apply -f create-persistent-vol.yaml
   13  cat > create-storage-class.yaml << EOF
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
EOF

   14  kubectl apply -f create-storage-class.yaml
   15  kubectl get persistentvolume
   16  kubectl get storageclass
   17  uptime
   18  history
   19  ll
   20  cat runWeathervane.pl
   21  vi runWeathervane.pl
   22  cat > weathervane.config.k8s.quickstart << EOF
{
  "description" : "micro",
  "configurationSize": "micro",
  "runStrategy" : "fixed",
  "dockerNamespace" : "mikemoranamd",
  "kubernetesClusters" : [
    {
      "name" : "appCluster",
      "kubeconfigFile" : "/var/run/kubernetes/admin.kubeconfig",
      "kubeconfigContext" : "",
    },
    {
      "name" : "driverCluster",
      "kubeconfigFile" : "/var/run/kubernetes/admin.kubeconfig",
      "kubeconfigContext" : "",
    },
  ],
  "driverCluster" : "driverCluster",
  "appInstanceCluster" : "appCluster",
  "appIngressMethod" : "clusterip",
  "cassandraDataStorageClass" : "local-storage",
  "postgresqlStorageClass" : "local-storage",
  "nginxCacheStorageClass" : "local-storage",
}
EOF

   23  vi *.q*
   24  ll
   25  history
root@mm60:~/weathervane#